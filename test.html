<script type="module">
    import "./node_modules/turbouuid/index.js"
    import { BigVec, BigVec128Array } from "./index.js"
    import LocalSharedMemory from "./node_modules/localsharedmemory/index.js"

    //self.memory = new LocalSharedMemory(1, 65536, true);

    self.wasm = {};
    
    WebAssembly.instantiateStreaming(fetch("src/manipulated.wasm"), self);


    (async () => {
        
        WebAssembly.instantiateStreaming(fetch("wasm/import.wasm"), self).then(i => {
            self.wasm = Object.assign({}, i.instance.exports);
            WebAssembly.instantiateStreaming(fetch("wasm/mt.wasm"), self).then(i => console.log(i.instance));
        });
        


        WebAssembly.instantiateStreaming(fetch("wasm/portal.wasm"), self).then(i => {
            console.warn(i)
            const portal = i.instance.exports;
    
            portal.boot().then(() => {
                const app = portal.install("wasm/window.wasm");
                const process = portal.start(app)
        
                console.log({app, process})
            })
        });

        console.log(BigVec.fromUUID('f81d4fae-7dec-11d0-a765-00a0c91e6bf6'));

        const arr = new BigVec128Array(3).random();
        console.log(arr);

        const wasm = fetch("wasm/event_loop.wasm");
        turboUUID.base(wasm).then(e => e.init()).then(base => setTimeout(() => {
            self.base = base;
            console.warn(base)
            return;

            self.jmap = new Map();
            self.array = new Array();

            let count, uuid, item, items = Reflect.ownKeys(self);

            count = (65536 * 1);//000;
            while (count--) {
                uuid = turboUUID();
                item = items.at(count % items.length);

                array.push(uuid);

                jmap.set(uuid, item);
                base.set(uuid, item);
            }

            console.table({
                first5: array.slice(0, 5),
                last5: array.slice(array.length - 5),
                jmapSize: [jmap.size],
                baseSize: [base.size()]
            });
            console.log("ready..")

            new BroadcastChannel("uuid").onmessage = e => {
                const uuid = e.data;
                const test = new Array(10).fill();
                console.warn(uuid);

                let eSum = 0;

                console.table(
                    test.map((u, i) => {
                        const t0 = performance.now();
                        const vm = jmap.get(uuid);
                        const tm = performance.now() - t0;

                        const t1 = performance.now();
                        const vb = base.get(uuid);
                        const tb = performance.now() - t1;

                        if (vm !== vb) throw `Indexed are different ${uuid} array[${vm}] !== base[${vb}]`;

                        const efficiency = tm / tb;
                        eSum += efficiency;

                        return {
                            index: vm,
                            tJMap: tm,
                            tBase: tb,
                            efficiency: efficiency
                        };
                    })
                );

                console.warn({
                    sampleCount: test.length,
                    indexDistance: (array.indexOf(uuid) / array.length).toFixed(2) * 1,
                    efficiency: (eSum / test.length)
                });

            }

            console.log("testing with [ self.test(i?) ]..")
            self.test = i => {
                const script = `close(new BroadcastChannel("uuid").postMessage(name))`;
                new Worker(URL.createObjectURL(new Blob([script])), {
                    name: array.at(i || (Math.random() * array.length))
                })
            };

            setTimeout(() => test(-2), 1000)
        }, 1000))
    });
</script>